#include <stdlib.h>     //exit()
#include <signal.h>     //signal()
#include <time.h>
#include "ADS1256.h"
#include <math.h>
#include <string.h>
#include <stdbool.h>
#include <wiringSerial.h>
#include <errno.h>
#include <fcntl.h> // for open
#include <sys/mman.h> // for mmap


#include <stdio.h>
#include <unistd.h>
#include "uart.h"

#define DEV_RST_PIN     18
#define DEV_CS_PIN      22
#define DEV_DRDY_PIN    17

#define ADS1256_TIME_OFFSET 725
#define SAMPLE_BUFFER_LENGTH 3000
#define OUTPUT_SAMPLE_FREQ 200
#define FILE_BUFFER_LENGTH OUTPUT_SAMPLE_FREQ*200 // 60 needed, 200 for good measure
#define CH 0 // 0 for Sensor, 1 for GPS PPS
#define AVE 50

int verbose = 0;
int calibrate_timing = 0;
int write_files = 1;
int no_timing = 1;
int display_every = 300;
int signed_samples = 0;

int display_count = 0;

volatile unsigned *TIMER_registers;
int serial_port ;
// sampling stuff
volatile unsigned int Sample_Index_I = 0; //index of where to put the next sample and time
volatile unsigned int Sample_Index_O = SAMPLE_BUFFER_LENGTH; //index of where to get the next sample and time
unsigned int Pa, Pb, Pc, PabDelta, PbcDelta; //time of previous 3 PPS inputs and the difference between them
unsigned int ConsistentPPS; //number of consecutive consistent PPS
unsigned int Wt[OUTPUT_SAMPLE_FREQ + 1]; //bounding times for the sample windows
unsigned int St[SAMPLE_BUFFER_LENGTH]; //time of raw sample
int S[SAMPLE_BUFFER_LENGTH]; //raw sample values
unsigned int SO[SAMPLE_BUFFER_LENGTH]; //sample output

//interim buffer
unsigned int file_buffer_SFE = 0;
unsigned int file_buffer[FILE_BUFFER_LENGTH] = { 0 };
unsigned int file_buffer_length = 0;
unsigned int interim_buffer_SFE = 0;
unsigned int interim_buffer[FILE_BUFFER_LENGTH] = { 0 };
unsigned int interim_buffer_length = 0;

volatile int file_to_write = 0;
volatile int one_good_file = 0;

unsigned int last_sample = 0;
int last_sample_time = 0;
FILE* debugfile;

unsigned int dispsamplecount = 0;
unsigned int dispsamplemin, dispsamplemax;
int ave_acc = 0;

void  Handler(int signo){
	//System Exit
	printf("\r\nEXITING\r\n");
	if (calibrate_timing) fclose(debugfile);
	DEV_ModuleExit();
	exit(0);
}

void TIMER_Init() {
	int TIMER_memFd;
	if ((TIMER_memFd = open("/dev/mem", O_RDWR) ) < 0) {
		printf("can't open /dev/mem - need root ?\n");
		exit(-1);
	}
	void *TIMER_map = mmap(NULL,4096, PROT_READ, MAP_SHARED, TIMER_memFd, 0x3F003000 ); /* Pi2/3/4 BCM System Timer */
	close(TIMER_memFd);
	if (TIMER_map == MAP_FAILED) {
		printf("mmap error %d\n", (int)TIMER_map);
		exit(-1);
	}
	TIMER_registers = (volatile unsigned *)TIMER_map;
}

bool AssignSamples() {
	int window = 0;
	int windowAccumulation = 0;
	int windowDivisor = 0;
	int HalfSampleOffset = PabDelta / (OUTPUT_SAMPLE_FREQ * 2);
	for (int i = 0; i < OUTPUT_SAMPLE_FREQ + 1; i++) Wt[i] = Pa + ((PabDelta * i) / OUTPUT_SAMPLE_FREQ) - HalfSampleOffset + ADS1256_TIME_OFFSET;
	while (Sample_Index_O != SAMPLE_BUFFER_LENGTH) { // while valid samples in buffer
		if (St[Sample_Index_O] >= Wt[window]) { // if the next sample is after the start of the window
			if (St[Sample_Index_O] >= Wt[window + 1]) { // if the sample is past the end of the current window
				if (windowDivisor == 0) return 0; // if there's a window with no samples, exit
				SO[window] = (windowDivisor > 0) ? windowAccumulation / windowDivisor : 0; // calculate the average of the samples in the window
				window++;
				if (window == OUTPUT_SAMPLE_FREQ) return 1; // if we reached the end of the last window then finish successfully
				windowAccumulation = 0;
				windowDivisor = 0;
			}
			windowAccumulation += S[Sample_Index_O];
			windowDivisor++;
		}
		if (calibrate_timing) {
			if (S[Sample_Index_O] > last_sample + 500) {
				fprintf(debugfile, "%d %u\r\n", last_sample_time - Pa, last_sample);
				fprintf(debugfile, "%d %u\r\n", St[Sample_Index_O] - Pa, S[Sample_Index_O]);
			}
			last_sample = S[Sample_Index_O];
			last_sample_time = St[Sample_Index_O];
		}
		Sample_Index_O++;
		if (Sample_Index_O == SAMPLE_BUFFER_LENGTH) Sample_Index_O = 0;
		if (Sample_Index_O == Sample_Index_I) { // run out of samples
			Sample_Index_O = SAMPLE_BUFFER_LENGTH;
			return 0;
		}
	}
	return 0;
}

void WriteOutputFile() {
	FILE* fp;
	char filename[80];
	sprintf(filename, "data/%u.dat", file_buffer_SFE);
	fp = fopen(filename, "w+");
	printf(filename);
	printf(" TIMESERIES AU_LILH_0_HHZ, %u samples, %u sps, ", file_buffer_length, OUTPUT_SAMPLE_FREQ);
	fprintf(fp, "TIMESERIES AU_LILH_0_HHZ, %u samples, %u sps, ", file_buffer_length, OUTPUT_SAMPLE_FREQ);
	time_t rawtime;
	time(&rawtime);
	rawtime = (time_t)file_buffer_SFE;
	struct tm* ptm;
	char date_buf[40];
	ptm = gmtime(&rawtime);
	strftime(date_buf, 40, "%FT%T.000", ptm);
	printf(date_buf);
	fprintf(fp, date_buf);
	printf(", SLIST, INTEGER, Counts\n");
	fprintf(fp, ", SLIST, INTEGER, Counts\n");
	for (int c = 0; c < file_buffer_length; c++) {
		fprintf(fp, "%u\r\n", file_buffer[c]);
	}
	fclose(fp);
	file_buffer_length = 0;
	file_buffer_SFE = 0;
	one_good_file = 1;
}

void displaySecondLine() {
	int max = 0;
	int min = (65536)-1;
	for (int i = 0; i < OUTPUT_SAMPLE_FREQ; i++) {
		if (SO[i] > max) max = SO[i];
		if (SO[i] < min) min = SO[i];
	}
	if (verbose) {
		printf(" ( %d / %d ) ", min, max);
		int cut_a = (min * 3 + max) / 4;
		int cut_b = (max * 3 + min) / 4;
		for (int i = 0; i < OUTPUT_SAMPLE_FREQ; i++) {
			if (SO[i] < cut_a) {
				printf(".");
 			} else if (SO[i] < cut_b) {
				printf("o");
			} else printf("O");
		}
		printf("\r\n");
	} else {
		printf("-");
		fflush(stdout);
	}
}

void writeSecondToInterimBuffer(int ending_SFE) {
	if (ending_SFE != 0) {
		for (int i = 0; i < OUTPUT_SAMPLE_FREQ; i++) {
			interim_buffer[interim_buffer_length] = SO[i];
			interim_buffer_length += 1;
		}
		if (interim_buffer_SFE == 0) {
			interim_buffer_SFE = ending_SFE - 1;//First second of buffer written
		}
	} else {
		interim_buffer_length = 0;
		printf("No SFE\r\n");
	}
	if ((interim_buffer_length >= 200) && (ending_SFE % 60 == 0)) {
		if (ending_SFE > 1000000000) {
			memcpy(file_buffer, interim_buffer, FILE_BUFFER_LENGTH * sizeof * interim_buffer);
			file_buffer_length = interim_buffer_length;
			file_buffer_SFE = interim_buffer_SFE;
			memset(interim_buffer, 0, FILE_BUFFER_LENGTH * sizeof * interim_buffer);
			interim_buffer_length = 0;
			interim_buffer_SFE = 0;
			file_to_write = 1;
		} else {
			printf("\nSFE too low: %12u\n", ending_SFE);
		}
	}
	displaySecondLine();
}

void PPSISR(){
	unsigned char fragment[256];
	int fragment_length=0;
	unsigned int SFE=0;
	Pa = Pb;
	Pb = Pc;
	Pc = TIMER_registers[1];
	PabDelta = Pb - Pa;
	PbcDelta = Pc - Pb;
	while (serialDataAvail(serial_port)>0) {
		if (fragment_length>255) fragment_length=0;
		fragment[fragment_length] = serialGetchar(serial_port);
		if (fragment[fragment_length]==10){
			fragment[fragment_length] = '\0';
			if (checksum(fragment)){
				SFE = get_SFE_From_GPRMC(fragment);
			} else {
				printf("(Checksum failed)");
			}
			fragment_length = 0;
		} else {
			fragment_length++;
		}
	}
	if (verbose) printf("\r\n");
	if (SFE>20) {
		if (verbose) printf(" ( SFE %d ) ",SFE);
	} else {
		printf(fragment);
		printf("\r\n");
		if (SFE == 1) {
			serialPuts(serial_port, "$PMTK314,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0*29\r\n"); // only send the RMC sentences
			printf("Reissued GPS data config\n");
		}
	}
	//printf("  %d  \r\n",TIMER_registers[1]);
	//printf("ISR\r\n");
	if ((990000 < PabDelta) && (PabDelta < 1010000) && (990000 < PbcDelta) && (PbcDelta < 1010000)) {
		if (verbose) printf(" (%d clk) ", PbcDelta - PabDelta);
		ConsistentPPS++;
		if (AssignSamples()) writeSecondToInterimBuffer(SFE);
	}
	else {
		ConsistentPPS = 0;
		printf("\r\ninconsistent %d - %d\r\n", PbcDelta, PabDelta);
	}
}

void DisplaySamples(int sample) {
	if (sample > dispsamplemax) dispsamplemax = sample;
	if (sample < dispsamplemin) dispsamplemin = sample;
	dispsamplecount++;
	ave_acc += sample;
	if (dispsamplecount == AVE) {
		sample = ave_acc / AVE;
		ave_acc = 0;
		for (int i = -100; i < 100; i++) {
			//if ((i >= dispsamplemin * 32 / (16777216)) && (i <= dispsamplemax * 32 / (16777216)))
			if ((i >= sample / (100)) && (i <= sample / (100)))
					printf("|");
			else
				printf(" ");
		}
		float mV = (sample / 16777216.0) * 5000.0;
		printf(" %d %fmV", sample, mV);
		printf("\r\n");
		dispsamplemin = sample;
		dispsamplemax = sample;
		dispsamplecount = 0;
	}
}

void SampleReadyISR() {
	St[Sample_Index_I] = TIMER_registers[1];
	int sample = ADS1256_Faster_Read_ADC_Data();
	if ((signed_samples==1) && (sample > (16777216 / 2))) sample -= 16777216;
	S[Sample_Index_I] = sample;
	//DisplaySamples(S[Sample_Index_I]);
	if (Sample_Index_O == SAMPLE_BUFFER_LENGTH) Sample_Index_O = Sample_Index_I;
	Sample_Index_I++;
	if (Sample_Index_I == SAMPLE_BUFFER_LENGTH) Sample_Index_I = 0;
	if (Sample_Index_I == Sample_Index_O) {
		printf("(Buffer Overflow) ");
		fflush(stdout);
		Sample_Index_O = SAMPLE_BUFFER_LENGTH;
	}
}

void Start_Continuous_Sampling() {
	//ADS1256_SetDiffChannal(CH);
	ADS1256_ConfigADC(ADS1256_GAIN_1, ADS1256_1000SPS);

	printf("registers: %X, %X, %X, %X, %X \n",
		ADS1256_Read_data(0),
		ADS1256_Read_data(1),
		ADS1256_Read_data(2),
		ADS1256_Read_data(3),
		ADS1256_Read_data(4)
		);
	//ADS1256_WriteCmd(CMD_SYNC);
	//ADS1256_WriteCmd(CMD_WAKEUP);
	DEV_Digital_Write(DEV_CS_PIN, 0);
	SPI_WriteByte(0xFC); // sync
	SPI_WriteByte(0x00); // wake up
	SPI_WriteByte(0x03); // read continuously
	DEV_Digital_Write(DEV_CS_PIN, 1);
	wiringPiISR(DEV_DRDY_PIN, INT_EDGE_FALLING, SampleReadyISR);

}

int main(int argc, char *argv[])
{
	for (int j=0; j<argc; j++) {
		if (!strcmp(argv[j], "-c")) calibrate_timing = 1;
		if (!strcmp(argv[j], "-v")) verbose = 1;
		if (!strcmp(argv[j], "-vv")) verbose = 2;
	}
	printf("I see you have %d args.\n", argc);

	if (calibrate_timing) debugfile = fopen("debug.csv", "w+");
	if ((serial_port = serialOpen ("/dev/ttyAMA0", 9600)) < 0) {
		fprintf (stderr, "Unable to open serial device: %s\n", strerror (errno)) ;
		return 1 ;
	}
	serialPuts(serial_port,"$PMTK314,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0*29\r\n");
	serialPuts(serial_port, "$PMTK220,200*2C\r\n"); // Increase update rate to 5Hz (200ms) for adafruit GPS
	if (wiringPiSetupGpio() < 0) { //use BCM2835 Pin number table
		Debug("set wiringPi lib failed	!!! \r\n");
		return 2;
	}
	else {
		Debug("set wiringPi lib success  !!! \r\n");
	}

	pinMode(DEV_RST_PIN, OUTPUT);
	pinMode(DEV_CS_PIN, OUTPUT);
	pinMode(DEV_DRDY_PIN, INPUT);

	wiringPiSPISetupMode(0, 1600000, 1);

	TIMER_Init();
	wiringPiISR(4,INT_EDGE_RISING, PPSISR);

    // Exception handling:ctrl + c
    signal(SIGINT, Handler);

    /*if (ADS1256_init() == 1) {
        printf("\r\nEND                  \r\n");
        DEV_ModuleExit();
        exit(0);
    }*/
	ADS1256_reset();
	DEV_Delay_ms(1);
	if (ADS1256_ReadChipID() == 3) {
		printf("ID Read success \r\n");
	}
	else {
		printf("ID Read failed \r\n");
		return 3;
	}
	DEV_Delay_ms(1);
	//ADS1256_SetMode(1); //differential mode
	//ADS1256_SetDiffChannal(0);
	DEV_Delay_ms(1);
	Start_Continuous_Sampling();
	DEV_Delay_ms(1);
	/*ADS1256_SetDiffChannal(0);
	ADS1256_SetDiffChannal(0);
	ADS1256_SetDiffChannal(0);
	ADS1256_SetDiffChannal(1);
	ADS1256_SetDiffChannal(1);
	ADS1256_SetDiffChannal(2);
	ADS1256_SetDiffChannal(2);
	ADS1256_SetDiffChannal(3);
	ADS1256_SetDiffChannal(3);
	ADS1256_SetDiffChannal(0);
	ADS1256_SetDiffChannal(0);
	ADS1256_SetDiffChannal(1);
	ADS1256_SetDiffChannal(1);
	ADS1256_SetDiffChannal(2);
	ADS1256_SetDiffChannal(2);
	ADS1256_SetDiffChannal(3);
	ADS1256_SetDiffChannal(3);
	ADS1256_SetDiffChannal(0);
	ADS1256_SetDiffChannal(0);
	ADS1256_SetDiffChannal(1);
	ADS1256_SetDiffChannal(1);
	ADS1256_SetDiffChannal(2);
	ADS1256_SetDiffChannal(2);
	ADS1256_SetDiffChannal(3);
	ADS1256_SetDiffChannal(3);*/
	
	//RequestSampleFromNewChannel(1);
	
	while(1){
		if ((file_to_write == 1) && (write_files == 1)) {
			WriteOutputFile();
			file_to_write = 0;
		}
		sleep(1);
    }
    return 0;
}

